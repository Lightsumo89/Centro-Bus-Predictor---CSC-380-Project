name: Deploy to Remote Server Automatically

on:
  push:
    branches: [ Production ]

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
    - name: Checkout code
      uses: actions/checkout@v3

    - name: Deploy to server - Part 1 (Setup and Install)
      uses: appleboy/ssh-action@master
      with:
        host: ${{ secrets.HOST }}
        username: ${{ secrets.USERNAME }}
        key: ${{ secrets.SSH_PRIVATE_KEY }}
        script: |
          # Create project directory if it doesn't exist
          mkdir -p ~/bus-tracking-app
          
          # Clone or pull the repository
          if [ -d ~/bus-tracking-app/.git ]; then
            cd ~/bus-tracking-app
            git fetch origin
            git checkout Production
            git pull origin Production
          else
            git clone -b Production https://github.com/Lightsumo89/Centro-Bus-Predictor---CSC-380-Project.git ~/bus-tracking-app
          fi
          
          # Find available Python 3 executable
          if command -v python3 &>/dev/null; then
            PYTHON_CMD="python3"
          elif command -v python &>/dev/null && python --version 2>&1 | grep -q "Python 3"; then
            PYTHON_CMD="python"
          else
            echo "Error: Python 3 not found. Please ensure Python 3 is installed."
            exit 1
          fi
          
          echo "Using Python: $($PYTHON_CMD --version)"
          
          # Go to the project directory
          cd ~/bus-tracking-app
          
          # Create directories for Python user packages if they don't exist
          mkdir -p ~/.local/bin
          mkdir -p ~/.local/lib/python3.10/site-packages
          
          # Add user bin directory to PATH (for this session)
          export PATH=$HOME/.local/bin:$PATH
          
          # Skip virtual environment - install directly to user space
          echo "Installing dependencies directly to user space..."
          $PYTHON_CMD -m pip install --user --upgrade pip
          $PYTHON_CMD -m pip install --user -r requirements.txt
          
          # Create a bin directory for any scripts
          mkdir -p ~/bin
          
          # Create a run script with better error handling
          cat > ~/bus-tracking-app/run.sh << 'EOL'
          #!/bin/bash
          cd ~/bus-tracking-app
          
          # Find the Python 3 executable
          if command -v python3 &>/dev/null; then
            PYTHON_BIN="python3"
          elif command -v python &>/dev/null && python --version 2>&1 | grep -q "Python 3"; then
            PYTHON_BIN="python"
          else
            echo "Error: Python 3 not found"
            exit 1
          fi
          
          # Kill any existing instances - don't exit if this fails
          echo "Attempting to stop any running instances..."
          pkill -f "python.*bus-api.py" || echo "No running instances found"
          sleep 2
          
          # Set environment variables
          export PORT=10589
          export FLASK_ENV=production
          export PYTHONPATH=$PYTHONPATH:~/bus-tracking-app
          export PATH=$HOME/.local/bin:$PATH
          
          # Create directories for output if they don't exist
          mkdir -p ~/logs
          
          # Start the application with logging
          echo "Starting application at $(date)" >> ~/logs/deploy.log
          cd Controller  # Change to the Controller directory before running the script
          nohup $PYTHON_BIN bus-api.py >> ~/logs/app.log 2>&1 &
          APP_PID=$!
          
          # Wait a bit and check if app is running
          sleep 5
          if ps -p $APP_PID > /dev/null; then
            echo "Application started successfully with PID $APP_PID" >> ~/logs/deploy.log
            echo "Application started on port $PORT"
            exit 0
          else
            echo "Application failed to start" >> ~/logs/deploy.log
            echo "Last 20 lines of app.log:" >> ~/logs/deploy.log
            tail -20 ~/logs/app.log >> ~/logs/deploy.log
            echo "Extended log for debugging:"
            tail -50 ~/logs/app.log
            exit 1
          fi
          EOL
          
          chmod +x ~/bus-tracking-app/run.sh

    - name: Deploy to server - Part 2 (Stop existing app)
      uses: appleboy/ssh-action@master
      with:
        host: ${{ secrets.HOST }}
        username: ${{ secrets.USERNAME }}
        key: ${{ secrets.SSH_PRIVATE_KEY }}
        script: |
          # Stop any existing instances - wrap in true to always return success
          echo "Stopping existing instances..."
          (pkill -f "python.*bus-api.py" || true)
          sleep 2
          echo "Any existing instances have been stopped."
          
    - name: Deploy to server - Part 3 (Start app and verify)
      uses: appleboy/ssh-action@master
      with:
        host: ${{ secrets.HOST }}
        username: ${{ secrets.USERNAME }}
        key: ${{ secrets.SSH_PRIVATE_KEY }}
        script: |
          # Start the application and capture the result
          echo "Starting application..."
          cd ~/bus-tracking-app
          ./run.sh || {
            echo "Run script failed. Checking logs:"
            echo "-------------- Last 20 lines of app.log --------------"
            tail -20 ~/logs/app.log || echo "Cannot access app.log"
            echo "-------------- End of app.log --------------"
            echo "-------------- deploy.log --------------"
            cat ~/logs/deploy.log || echo "Cannot access deploy.log"
            echo "-------------- End of deploy.log --------------"
            exit 1
          }
          
          # Final verification
          echo "Verifying deployment..."
          if pgrep -f "python.*bus-api.py" > /dev/null; then
            echo "✅ Application is running!"
          else
            echo "❌ Application is not running. Deployment failed."
            exit 1
          fi
